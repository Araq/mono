import basem, logm, parsersm, jsonm
import ./sqlm, ./dbm

export sqlm, dbm

# DbTable ------------------------------------------------------------------------------------------
type DbTable*[T] = object
  db*:      Db
  name*:    string
  ids*:     seq[string]
  auto_id*: bool

proc log[T](table: DbTable[T]): Log = Log.init("db", table.db.id)


# db.table -----------------------------------------------------------------------------------------
proc table*[T](
  db:       Db,
  _:        type[T],
  name:     string,
  ids     = @["id"],
  auto_id = false
): DbTable[T] =
  DbTable[T](db: db, name: name, ids: ids, auto_id: auto_id)


# o.column_names -----------------------------------------------------------------------------------
proc column_names*[T](o: T): seq[string] =
  when compiles(o.custom_column_names): o.custom_column_names
  else:                                 o.field_names

# table.create -------------------------------------------------------------------------------------
proc create*[T](table: DbTable[T], o: var T): void =
  # `skip_id` for tables with auto increment id
  table.log.with((table: table.name, id: o.id)).info "{table}.create id={id}"
  let query = block:
    let column_names = if table.auto_id: o.column_names.filter((n) => n notin table.ids)
    else:                                o.column_names
    let names = " " & column_names.join(",  ")
    let values = column_names.map((n) => fmt":{n}").join(", ")
    let ids = table.ids.join(", ")
    fmt"""
      insert into {table.name}
        ({names})
      values
        ({values})
      returning {ids}
    """.dedent

  # table.db.exec(sql(query, o, false), log = false)
  let rows = table.db.get_raw(sql(query, o, false), log = false)

  # updating ids, in case it was auto-generated by database
  if rows.len < 1: throw "didn't get any returning ids from insert"
  if rows.len > 1: throw fmt"got too many returning ids {rows.len} from insert"
  o.update_from rows[0]


# table.update -------------------------------------------------------------------------------------
proc update*[T](table: DbTable[T], o: T): void =
  table.log.with((table: table.name, id: o.id)).info "{table}.update id={id}"
  let query = block:
    let setters = o.column_names.filter((n) => n notin table.ids).map((n) => fmt"{n} = :{n}").join(", ")
    let where = table.ids.map((n) => fmt"{n} = :{n}").join(" and ")
    fmt"""
      update {table.name}
      set
        {setters}
      where {where}
    """.dedent
  table.db.exec(sql(query, o), log = false)


# table.save ---------------------------------------------------------------------------------------
proc save*[T](table: DbTable[T], o: var T): void =
  table.log.with((table: table.name)).info "{table}.save"
  let query = block:
    let column_names = if table.auto_id: o.column_names.filter((n) => n notin table.ids)
    else:                                o.column_names
    let ids = table.ids.join(", ")
    let insert_columns = " " & column_names.join(",  ")
    let insert_values  = column_names.map((n) => fmt":{n}").join(", ")
    let setters = column_names.map((n) => fmt"{n} = excluded.{n}").join(", ")
    fmt"""
      insert into {table.name}
        ({insert_columns})
      values
        ({insert_values})
      on conflict ({ids}) do update
      set
        {setters}
      returning {ids}
    """.dedent

  # table.db.exec(sql(query(), o, false), log = false)
  let rows = table.db.get_raw(sql(query, o, false), log = false)

  # updating ids, in case it was auto-generated by database
  if rows.len < 1: throw "didn't get any returning ids from save"
  if rows.len > 1: throw fmt"got too many returning ids {rows.len} from save"
  o.update_from rows[0]


# build_table_query --------------------------------------------------------------------------------
proc build_table_query[W](table_name: string, select: string, where: W, normalise = false): SQL =
  let (where_conditions, values) =
    when where is SQL:
      where
    elif where is tuple:
      let conditions = where.field_names.map((name) => fmt"{name} = :{name}").join(" and ")
      sql(conditions, where)
    elif where is string or where is int:
      sql "id = {where}"
    else:
      throw fmt"unsupported where clause {where}"

  var query = fmt"""
    select {select}
    from   {table_name}
    where  {where_conditions}
  """.dedent

  if normalise: # used for testing
    query = query.replace("\n", " ").replace(re"\s+", " ").replace(re"\s+$", "")

  sql(query, values)

test "build_query":
  assert build_table_query(
    "users", "*", sql"id = {1}", normalise = true
  ) == sql(
    "select * from users where id = :id", (id: 1)
  )

  assert build_table_query(
    "users", "*", (id: 1), normalise = true
  ) == sql(
    "select * from users where id = :id", (id: 1)
  )

  assert build_table_query(
    "users", "*", 1, normalise = true
  ) == sql(
    "select * from users where id = :id", (id: 1)
  )

# table.filter -------------------------------------------------------------------------------------
proc filter*[T, W](table: DbTable[T], where: W = sql"", log = true): seq[T] =
  if log: table.log.with((table: table.name, where: $where)).info "{table}.get {where}"
  # let column_names = T.field_names.join(", ")
  let query = build_table_query(table.name, "*", where)
  table.db.get(query, T, log = false)


# table.get_one -----------------------------------------------------------------------------------
proc fget*[T, W](table: DbTable[T], where: W = sql"", log = true): Option[T] =
  if log: table.log.with((table: table.name, where: $where)).info "{table}.get_one {where}"
  let found = table.filter(where, log = false)
  if found.len > 1: throw fmt"expected one but found {found.len} objects"
  if found.len > 0: found[0].some else: T.none


# table.refresh ------------------------------------------------------------------------------------
# Reload from the database
proc refresh*[T](table: DbTable[T], o: T, log = true): T =
  let where_query = table.ids.map((n) => fmt"{n} = :{n}").join(" and ")
  let where = sql(where_query, o, false)
  if log: table.log.with((table: table.name, where: $where)).info "{table}.refresh {where}"
  table.fget(where, log = false).ensure fmt"can't refresh {where}"


# table.count --------------------------------------------------------------------------------------
proc count*[T, W](table: DbTable[T], where: W = sql""): int =
  table.log.with((table: table.name, where: $where)).info "{table}.count {where}"
  let query = build_table_query(table.name, "count(*)", where)
  table.db.get_one(query, int, log = false)


# table.contains -----------------------------------------------------------------------------------
proc contains*[T, W](table: DbTable[T], where: W = sql""): bool =
  table.count(where) > 0


# [] -----------------------------------------------------------------------------------------------
proc `[]`*[T, W](table: DbTable[T], where: W): T =
  table.fget(where).get

proc `[]`*[T, W](table: DbTable[T], where: W, default: T): T =
  table.fget(where).get(default)


# Test ---------------------------------------------------------------------------------------------
if is_main_module:
  let db = Db.init
  db.define("nim_test")

  db.before sql"""
    drop table if exists test_db_table_users;

    create table test_db_table_users(
      id   integer      not null,
      name varchar(100) not null,
      age  integer      not null,

      primary key (id)
    );
  """


  # Defining User Model
  type User = object
    id:   int
    name: string
    age:  int

  let users = db.table(User, "test_db_table_users")

  # Saving
  var jim = User(id: 1, name: "Jim", age: 30)
  users.create jim

  users.save jim

  jim.age = 31
  users.save jim

  # refresh
  assert users.refresh(jim) == jim

  # filter
  assert users.filter(sql"age = {31}") == @[jim]
  assert users.filter((age: 31))       == @[jim]
  assert users.filter(1)               == @[jim]

  # []
  assert users[sql"age = {31}"] == jim
  assert users[(age: 31)]       == jim
  assert users[1]               == jim

  # count, has
  assert users.count((age: 31)) == 1
  assert (age: 31) in users

  # Cleaning
  db.exec sql"drop table if exists test_db_table_users"